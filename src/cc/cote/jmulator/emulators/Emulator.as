package cc.cote.jmulator.emulators {	import flash.display.InteractiveObject;	import flash.events.EventDispatcher;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.utils.Dictionary;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		import cc.cote.jmulator.events.*;		/**	 * The <code>Emulator</code> class is an abstract class which is used, and extended, by the 	 * board-specific classes in the <code>emulators</code> package. The <code>Emulator</code> class 	 * cannot be instantiated directly. Instead, use the board-specific class matching the device 	 * you wish to use.	 * 	 * @author Jean-Philippe Côté	 * @see cc.cote.jmulator.emulators	 * @see http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/EventDispatcher.html 	 * 		flash.events.EventDispatcher 	 * @see http://cote.cc/projects/jmulator	 * 	 * 	 * @todo Allow typematic changes after the object is created (with a setter)	 * @todo Include a functionality to selectively exclude keyups and keydowns	 * @todo Allow typematic feature on a per keyCode basis	 * 	 * @todo Add support for additional keyboard emulators/encoders. Here are a few that could be 	 * added :	 * 	 * 		- http://www.groovygamegear.com/screenshots.html	 * 		- http://www.hagstromelectronics.com/products/modules.html	 * 		- http://www.vetra.com/Encoder2.htm	 * 		- http://www.piengineering.com/custom/xkmatrix.php	 * 		- http://www.happcontrols.com/joysticks/950800xx.htm	 * 		- http://www.audon.co.uk/kbe-629.html	 */	public class Emulator extends EventDispatcher	{						/** 		 * The type of events that should be triggered by the <code>Emulator</code> object. It can 		 * be set to trigger events when inputs are activated only (EmulatorTriggerMode.TRIGGER_ON), 		 * when they are deactivated only (EmulatorTriggerMode.TRIGGER_OFF) or on both activation 		 * and deactivation (EmulatorTriggerModeTRIGGER_BOTH).		 *		 * @default EmulatorTriggerMode.TRIGGER_BOTH		 */		public var triggering:String = EmulatorTriggerMode.TRIGGER_BOTH;				/** 		 * A boolean specifying whether or not to ignore the OS typematic feature. If typematic is 		 * enabled (it usually is), a stream of events will be triggered if the input stays 		 * activated for a while.		 * 		 * @default false		 */		public var typematic:Boolean = false;				/** @private */		private var _supportedBoards:Vector.<Class> = new <Class>[			Ipac2,			Ipac4,			IpacVe		];				/** @private Needed because we use getDefinitionByName() */		private var _boardEventClasses:Vector.<Class> = new <Class>[			Ipac2Event,			Ipac4Event,			IpacVeEvent		];				/** @private */		private var _map:Dictionary = new Dictionary();				/** @private */		private var _activatedInputs:Array = new Array();				/** @private */		private var _BoardEventClass:Class;				/** @private */		private var _listenOn:InteractiveObject;																			/**		 * Constructor (private). Cannot be instantiated directly. Use a board-specific class 		 * instead.		 * 		 * @param listenOn 		An InteractiveObject to attach the keyboard listener to. Usually 		 * 						this is the Stage.		 * @param typematic 	Whether or not to use the OS typematic feature. When the typematic 		 * 						feature is enabled, the OS repeatedly sends keydown events when a 		 * 						key is being held down.		 * @param triggering 	Triggering method : on button press only 		 * 						(EmulatorTriggerMode.TRIGGER_ON), on button release only 		 * 						(EmulatorTriggerMode.TRIGGER_OFF) or on both press and release 		 * 						(EmulatorTriggerMode.TRIGGER_BOTH).		 * 		 * @throws Error 		The Emulator class cannot be instantiated directly. Use a subclass 		 * 						from the emulators package.		 */				public function Emulator(			listenOn:InteractiveObject, 			typematic:Boolean = false, 			triggering:String = EmulatorTriggerMode.TRIGGER_BOTH		):void {									// Enforce the fact that this class is abstract and should not be			// instantiated directly			if (Object(this).constructor == Emulator) {				throw( 					new Error(						"The Emulator class cannot be instantiated directly. " + 						"Use a subclass from the emulators package."					)				);			}						// Store parameters in object properties			this._listenOn = listenOn;			this.typematic = typematic;			this.triggering = triggering;						// Add keyboard listeners (DO NOT USE WEAK LISTENERS OR EVERYTHING STOPS WORKING!!!)			this._listenOn.addEventListener(KeyboardEvent.KEY_DOWN, _onKeyDown);			this._listenOn.addEventListener(KeyboardEvent.KEY_UP, _onKeyUp);					}		/** @private */			private function _onKeyDown(e:KeyboardEvent):void {								// Try to fetch string for that code. If it fails, return immediately			var events:Array = _getEvents(e.keyCode);			if (!events) return;						// Loop through all events found for the keyCode			var i:uint = 0;			for each (var s:String in events) {								var input:String = s.split("input_").pop();							// Dispatch event, or not, based on the typematic setting				if (typematic) {					if (						triggering == EmulatorTriggerMode.TRIGGER_ON || 						triggering == EmulatorTriggerMode.TRIGGER_BOTH					) {						dispatchEvent(new boardEventClass(s, true, input));						dispatchEvent(							new boardEventClass(boardEventClass['ANY_INPUT'], true, input)						);					}									} else {										// If the keyCode is not already active, dispatch the event 					// only if triggering mode is set to ON or BOTH)					if (						_activatedInputs.indexOf(e.keyCode) < 0 && 						(triggering == EmulatorTriggerMode.TRIGGER_BOTH || 						triggering == EmulatorTriggerMode.TRIGGER_ON)					) {						dispatchEvent(new boardEventClass(s, true, input));						dispatchEvent(new boardEventClass(							boardEventClass['ANY_INPUT'], true, input)						);					} else {						// If the keyCode is already active but there is more than one event for 						// that keycode						if ( i > 0 && 							(triggering == EmulatorTriggerMode.TRIGGER_BOTH || 							triggering == EmulatorTriggerMode.TRIGGER_ON) 						) {							dispatchEvent(new boardEventClass(s, true, input));							dispatchEvent(								new boardEventClass(boardEventClass['ANY_INPUT'], true, input)							);						}					}									}								// If the keyCode is not already in the activated list, add it				if (_activatedInputs.indexOf(e.keyCode) < 0 ) {						_activatedInputs.push(e.keyCode);				}								i++;							}					}				/** @private */						private function _onKeyUp(e:KeyboardEvent):void {						// Try to fetch events associated with that code. If it fails, 			// return immediately			var events:Array = _getEvents(e.keyCode);			if (!events) return;						// Loop through each event found			for each (var s:String in events) {								var input:String = s.split("input_").pop();							if (					triggering == EmulatorTriggerMode.TRIGGER_OFF || 					triggering == EmulatorTriggerMode.TRIGGER_BOTH				) {					dispatchEvent(new boardEventClass(s, false, input));					dispatchEvent(						new boardEventClass(boardEventClass['ANY_INPUT'], false, input)					);				}								// Always remove the keyCode from the list of activated keyCodes				var pos:int = _activatedInputs.indexOf(e.keyCode);				_activatedInputs.splice(pos, 1);							}					}				/**		 * Retrieves an array of all the emulator event(s) registered to a specific key code. On 		 * certain emulators (the I-PAC, for example), there can be more than one input registered 		 * to a single key code.		 * 		 * <p>The value 'disabled' can also be passed as a parameter to lookup disabled key codes for 		 * the board.</p>		 * 		 * @param 	keyCode Keyboard keycode (ascii code)		 * @return 	An array of emulator event types		 * 		 * @private		 */						private function _getEvents(keyCode:*):Array {				return map[keyCode];		}						/**		 * Retrieves the key code associated with a specific board input		 * 		 * @param input Board input label		 */						private function _getKeyCode(input:String):uint {							// Loop through all arrays associated with all keys to find one the key associated with 			// the requested input.			for (var key:* in map) {								var i:uint = 0;				for each (var s:String in map[key]) {					if (s == input) { return key; }				}				i++;			}						// If nothing is found 			return 0;		}				/**		 * Returns the current status (activated or not) of a specific board input.		 * 		 * @param 	input Board input label		 * @return 	A boolean indicating if the input is in active mode (true) or inactive mode 		 * 			(false).		 */				public function isActive(input:String):Boolean {			var code:uint = _getKeyCode(input);						if (_activatedInputs.indexOf(code) == -1) {				return false;			} else {				return true;			}		}				/**		 * Encodes string into JSON-compatible format. 		 * 		 * This function has been extracted from the JSONEncoder.as class written by Lawrence S. 		 * Maccherone which I believed is itself derived from the as3corelib library.		 *		 * @param str The string to encode		 * @return a JSON-encoded version of the input string		 * 		 * @private		 */		private function _convertToJson(str:String):String {						// Variable to hold the json output			var json:String = "";						// Character currently being processed			var char:String;						// Check all characters and encode them if necessary			for (var i:uint = 0; i < str.length; i++) {								char = str.charAt(i);								switch ( char ) {										case '"':	// quotation mark						json += "\\\"";						break;										case '/':	// solidus						json += "\\/";						break;										case '\\':	// reverse solidus						json += "\\\\";						break;										case '\b':	// bell						json += "\\b";						break;										case '\f':	// form feed						json += "\\f";						break;										case '\n':	// newline						json += "\\n";						break;										case '\r':	// carriage return						json += "\\r";						break;										case '\t':	// horizontal tab						json += "\\t";						break;										default:	// everything else												// check for a control character and escape as unicode						if ( char < ' ' ) {							// get the hex digit(s) of the character (either 1 or 2 digits)							var hexCode:String = char.charCodeAt( 0 ).toString( 16 );														// ensure that there are 4 digits by adjusting							// the # of zeros accordingly.							var zeroPad:String = hexCode.length == 2 ? "00" : "000";														// create the unicode escape sequence with 4 hex digits							json += "\\u" + zeroPad + hexCode;						} else {														// no need to do any special encoding, just pass-through							json += char;													}				}							}						return '"' + json + '"';		}				/**		 * Properly disposes of ressources used by the object, namely, the listeners.		 */		public function dispose():void {			_listenOn.removeEventListener(KeyboardEvent.KEY_DOWN, _onKeyDown);			_listenOn.removeEventListener(KeyboardEvent.KEY_UP, _onKeyUp);		}			/** Indicates if the capsLock key is currently engaged (true) or not (false). */		public function get capsLock():Boolean {			return Keyboard.capsLock;		}				/** Indicates if the numLock key is currently engaged (true) or not (false). */		public function get numLock():Boolean {			return Keyboard.numLock;		}				/**		 * A JSON representation of the board label to keyboard key mappings (useful for debugging).		 */		public function get jsonLabelMap():String {						// Create string to hold output			var json:String = '';						// Count number of items in Dictionary for later use			var n:int = 0;			for (var k:* in map) n++;						// Iterate through all items in the Dictionary keeping track of			// iterations			var i:uint = 0;			for (var key:Object in map) {								json += "\t";								if (key is Number) {					json += map[key].toString() + ': ' + _convertToJson(String.fromCharCode(key));				} else if (key == 'disabled') {					json += map[key].toString() + ': false';				}								if (i < n - 1) json += ",\n";								i++;			}						return "{\n" + json + "\n}";		}				/** The class of the currently-used emulator device. */		public function get boardEventClass():Class {			var board:String = getQualifiedClassName(this).split("::").pop();			return getDefinitionByName('cc.cote.jmulator.events.' + board + 'Event') as Class;		}		/** A list of the mappings between key codes (as sent by the board) and event names. */		public function get map():Dictionary {			return _map;		}		/** List of emulator boards supported by this library. */		public function get supportedBoards():Vector.<Class> {			return _supportedBoards;		}		/** The object the emulator is listening on for key events. This is typically the stage. */		public function get listenOn():InteractiveObject {			return _listenOn;		}	}	}